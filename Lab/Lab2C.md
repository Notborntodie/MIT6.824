[TOC]

## Part 2C: 持久化



重新回顾<img src="http://cdn.zhengyanchen.cn/img202304182247712.png" alt="截屏2023-03-15 17.02.21"  />

这张图

如果基于Raft的服务器重启，它应该在离开的地方恢复服务。这需要Raft保持持久状态，以在重启后生存。论文中的图2提到了哪些状态应该是持久的。

![截屏2023-03-25 17.35.39](http://cdn.zhengyanchen.cn/img202304182240815.png)

真实的实现会在每次更改Raft的持久状态时将其写入磁盘，并在重启后从磁盘读取状态。您的实现不会使用磁盘；相反，它将从`Persister`对象（请参见`persister.go`）保存和恢复持久状态。调用Raft.Make()的人会提供一个最初保存Raft最近持久状态（如果有的话）的Persister。Raft应该从该Persister初始化其状态，并且应该在状态更改时使用它来保存其持久状态。使用Persister的ReadRaftState()和Save()方法。

* 通过在`raft.go`中添加代码保存和还原持久状态，完成`persist()`和`readPersist()`函数。您需要将状态编码（或“序列化”）为字节数组，以便将其传递给Persister。使用`labgob`编码器；请参见`persist()`和`readPersist()`中的注释。labgob类似于Go的gob编码器，但是如果您尝试编码具有小写字段名称的结构，则会打印错误消息。

* 现在，将nil作为第二个参数传递给`persister.Save()`。

* 在您的实现更改持久状态的点插入调用 `persist()`。完成此操作后，如果您的其余实现正确，则应通过所有2C测试。



**需要持久化的点**

依然需要注意，我的`readPersist`和`persist()`都是没有加锁的，我想一旦raft需要持久化的状态被修改，那么就要调用`persist()`函数，而这些状态被修改的时候一定是持锁的。

* 当客户端增加log的时候，`Start` 函数这里

```go
rf.logs = append(rf.logs, newEntry) //append the new entry to the log
rf.persist()                        //persist the log
```









您可能需要将nextIndex的优化备份超过一个条目。查看从第7页底部和第8页顶部（由灰色线标记）开始的扩展Raft论文。论文对细节含糊不清；您需要填补空白。一种可能性是使拒绝消息包括：

```
 XTerm:  term in the conflicting entry (if any)
 XIndex: index of first entry with that term (if any)
 XLen:   log length
```

然后，领导者的逻辑可以是：

情况1：领导者没有XTerm： nextIndex = XIndex 

情况2：领导者有XTerm： nextIndex 领导者的最后一个XTerm条目 		

情况3：追随者的日志太短： nextIndex = XLen

一些其他提示： 运行git pull以获取最新的实验室软件。 2C测试比2A或2B测试要求更高，失败可能是由于2A或2B的代码问题引起的。 您的代码应通过所有2C测试（如下所示），以及2A和2B测试。

## gpt

### 如果raft的部分状态(包括日志)会定时被持久化，那么快照地意义是什么？

即使Raft协议中的部分状态（包括日志）定期被持久化，快照仍然具有重要意义。

在Raft中，由于日志条目的数量可能会非常大，为了减少Raft的恢复时间和存储空间，快照是非常必要的。快照只包含一份服务器状态的完整副本，而不是之前所有的日志条目。因此，如果服务器的状态已经达到了快照点，那么它可以丢弃快照点之前的所有日志条目，只需要保存快照点之后的所有日志条目即可。这可以大大减少恢复时间和存储空间，从而提高系统性能。

此外，即使Raft协议的部分状态被持久化，快照还是很重要的。快照可以提供一种快速和方便的方法来恢复服务器的状态。在快照被创建时，它包含了一个完整的状态副本，包括应用程序数据和Raft日志。因此，如果服务器需要快速恢复其状态，它可以使用最近的快照来恢复其状态，而不需要再重新执行所有的日志条目。这可以提高恢复的速度，并减少服务的停机时间。

因此，即使Raft的部分状态被定期持久化，快照仍然具有很重要的意义，可以提高系统的性能和可用性。

### ==快照与其说是raft的备份，不如说是状态机的备份==

您说得很对，快照确实更多地是作为状态机的备份，而不是Raft协议本身的备份。

在Raft协议中，快照被用来减少存储和传输日志条目的数量。快照只包含一个完整的状态副本，而不是之前所有的日志条目。这可以减少传输的数据量，并在恢复时减少恢复的时间。但是，快照不是Raft协议本身的备份，因为快照并没有记录所有的Raft状态信息。例如，它没有记录当前的任期号和投票状态，这些信息仍需要通过Raft日志来进行维护和恢复。

相反，快照更像是状态机的备份。在快照中，包含了一个完整的状态副本，包括应用程序数据和Raft日志。这可以使状态机在需要时快速地恢复其状态，而无需重新执行所有的日志条目。因此，快照更多地是作为状态机的备份，而不是Raft协议本身的备份。

总之，快照在Raft协议中的作用是减少存储和传输日志条目的数量，并在恢复时减少恢复的时间。但是，它更像是状态机的备份，而不是Raft协议本身的备份。

### 所以在Lab 2C我其实要做的是raft服务的持久化?

是的，您说得对。在Lab 2C中，您需要实现Raft服务的持久化，以便在重启后能够恢复服务状态。具体而言，您需要将Raft的持久状态写入磁盘，并在重新启动后从磁盘中读取状态。为了避免使用磁盘，您将使用一个Persister对象来保存和恢复持久状态。

当然，持久化不仅仅是为了在重启后恢复服务状态。持久化还可以确保Raft协议的持久性，即使在发生故障时也可以保持协议的正确性和一致性。因此，持久化是Raft协议中非常重要的一个方面。

### 为什么要持久化voteFor?







