## Part 2D: 日志压缩

在现有情况下，重新启动的服务器会重放完整的Raft日志，以恢复其状态。然而，长期运行的服务不可能永远记住完整的Raft日志。相反，您将修改Raft，使其与服务合作，这些服务定期存储其状态的“快照”，此时Raft将丢弃在快照之前的日志条目。结果是更小的持久数据量和更快的重启时间。

但是，现在可能会出现跟随者落后太多，以至于领导者已经丢弃了其需要赶上的日志条目；领导者必须发送快照以及从快照时间开始的日志。扩展Raft论文的第7节概述了该方案；您需要设计细节。

您可能会发现参考Raft交互图有助于了解复制服务和Raft如何进行通信。

<img src="http://cdn.zhengyanchen.cn/img202304182247712.png" alt="截屏2023-03-15 17.02.21"  />

您的Raft必须提供以下功能，该服务可以使用序列化的状态快照调用：

`Snapshot（index int，snapshot []byte()]`

在Lab 2D中，测试器定期调用`Snapshot()`。在Lab 3中，您将编写一个键/值服务器，该服务器调用`Snapshot()`；快照将包含键/值对的完整表。服务层在每个对等体上调用`Snapshot()`（而不仅仅是领导者）。

`index`参数表示快照中反映的最高日志条目。 Raft 应该在该点之前丢弃其日志条目。您需要修改Raft代码，以便仅使用日志的尾部运行。





您需要实现扩展论文中讨论的`InstallSnapshot` RPC，该RPC允许Raft领导者告诉滞后的Raft对等体使用快照替换其状态。您可能需要考虑InstallSnapshot如何与Figure 2中的状态和规则交互。

当一个跟随者的Raft代码接收到InstallSnapshot RPC时，它可以使用applyCh将快照发送到ApplyMsg中的服务。 ApplyMsg结构定义已经包含您需要的字段（测试器也期望如此）。请注意，这些快照只会推进服务的状态，而不会使其向后移动。

如果服务器崩溃，它必须从持久数据重新启动。您的Raft应该保存Raft状态和相应的快照。使用persister.Save（）的第二个参数保存快照。如果没有快照，则将其作为第二个参数传递为空值。

当服务器重新启动时，应用层读取持久快照并恢复其保存的状态。

实现Snapshot（）和InstallSnapshot RPC以及支持这些的Raft更改（例如，使用修剪日志操作）。您的解决方案在通过2D测试（以及所有先前的Lab2测试）时才算完成。

为了开始，您可以修改代码，使其能够仅存储从某个索引X开始的日志部分。最初，您可以将X设置为零并运行2B / 2C测试。然后，使Snapshot（index）丢弃索引之前的日志，并将X设置为索引。如果一切顺利，您现在应该通过第一个2D测试。

您将无法将日志存储在Go切片中并可互换使用Go切片索引和Raft日志索引；您需要以考虑到日志已丢弃的部分的方式对切片进行索引。

接下来：如果领导者没有所需的日志条目来使追随者保持最新状态，则让其发送InstallSnapshot RPC。

在单个InstallSnapshot RPC中发送整个快照。不要实现图13的偏移机制以拆分快照。

Raft必须以允许Go垃圾收集器释放和重用内存的方式丢弃旧的日志条目；这要求丢弃的日志条目没有可达的引用（指针）。

即使日志被修剪，您的实现仍然需要正确地在AppendEntries RPC中发送新条目之前的条目的任期和索引；这可能需要保存并引用最新快照的lastIncludedTerm / lastIncludedIndex（请考虑是否应该将其持久化）。

在没有-race的情况下消耗完整组Lab 2测试（2A + 2B + 2C + 2D）的合理时间是6分钟的实际时间和1分钟的CPU时间。在使用-race时，它大约需要10分钟的实际时间和2分钟的CPU时间。

您的代码应该通过所有2D测试（如下所示），以及2A，2B和2C测试。