# Raft（翻译）3

[TOC]

## 7 日志压缩

Raft的日志在正常操作中会增长以包含更多客户请求，但在实际系统中，它不能无限增长。随着日志变得越来越长，它占用的空间和重放所需的时间也会增加。如果没有一些机制来丢弃已经积累在日志中的过时信息，这将最终导致可用性问题。

==**快照**是压缩的最简单方法==。在快照中，当前整个系统状态被写入到一个稳定存储器中，然后整个日志被丢弃到该点。快照在Chubby和ZooKeeper中使用，本节剩余部分将介绍Raft中的快照。

**增量压缩方法**如日志清理[36]和日志结构化合并树[30, 5]，也是可能的。它们一次操作一部分数据，因此它们可以更均匀地分散压缩负载。它们首先选择一个已经累积了许多已删除和覆盖对象的数据区域，然后更紧密地重写该区域中的实时对象并释放该区域。与快照相比，这需要显着的额外机制和复杂性，快照始终在整个数据集上操作，简化了问题。虽然日志清理需要对Raft进行修改，但状态机可以使用与快照相同的接口实现LSM树。



<img src="http://cdn.zhengyanchen.cn/img202304181738079.png" alt="截屏2023-04-18 17.38.40" style="zoom:80%;" />

图12展示了Raft中快照的基本思想。每个服务器独立地进行快照，仅**覆盖其日志中的已提交条目**。大部分工作包括状态机将其当前状态写入快照。

Raft还在快照中包含少量元数据：

* 最后包含的索引(**last included index**)是快照所替换的日志中最后一个条目的索引（状态机已应用的最后一个条目），

* 最后包含的任期(**last included term**)是该条目的任期。

  这些被保留以支持附加日志一致性检查( **AppendEntries consistency check**)，以查找快照之后的第一个日志条目，因为该条目需要先前的日志索引和任期。为了启用群集成员更改（第6节），快照还包括截至最后包含索引的日志中最新的配置。一旦服务器完成写入快照，它可以删除所有日志条目，包括截至最后包含的索引和任何之前的快照。

尽管服务器通常==独立地进行快照==，但是领导者必须偶尔将快照发送给滞后的跟随者。

这种情况发生在领导者已经丢弃了需要发送给跟随者的下一个日志条目的情况下。幸运的是，在正常操作中，已经跟上领导者的跟随者已经拥有这个条目。然而，一个非常缓慢的跟随者或加入集群的新服务器（第6节）可能没有这个条目。为了使这样的跟随者保持最新，领导者需要通过网络向其发送一个快照。



<img src="http://cdn.zhengyanchen.cn/img202304181830895.png" alt="截屏2023-04-18 18.30.35" style="zoom:80%;" />



领导者使用称为**InstallSnapshot**的新RPC向落后的跟随者发送快照，如图13所示。当一个跟随者使用这个RPC接收到快照时，它必须决定如何处理现有的日志条目。通常情况下，快照将包含接收者日志中不存在的新信息。在这种情况下，跟随者丢弃其整个日志，因为快照已经包含了所有的日志条目，而且可能存在与快照冲突的未提交的条目。如果跟随者收到描述其日志前缀的快照（由于重传或错误导致），那么快照覆盖的日志条目将被删除，但是快照之后的日志条目仍然是有效的，必须保留。

这种快照方法背离了Raft的强领导者原则，因为跟随者可以在没有领导者知情的情况下进行快照。然而，我们认为这种变化是合理的。虽然拥有一个领导者有助于避免在达成共识时产生冲突的决策，但在进行快照时已经达成了共识，因此没有决策会产生冲突。数据仍然只从领导者流向跟随者，只是跟随者现在可以重新组织他们的数据。

### 没看懂，解释？

在Raft中，领导者负责维护日志条目的复制和提交，以及维护集群中所有服务器的一致性。领导者通过发送RPC将新的日志条目复制到所有的跟随者中，以确保所有服务器都有相同的日志条目，并在提交一个日志条目时通知所有服务器。

然而，在某些情况下，领导者可能无法将日志条目复制到所有的跟随者中。例如，某些跟随者可能因为网络延迟或故障而落后于领导者，或者新的服务器可能加入到集群中。在这种情况下，领导者可能需要将自己的状态作为快照发送给落后的跟随者，以帮助跟随者重新同步其状态。

然而，Raft的强领导者原则要求所有的状态变更都必须经过领导者，并且跟随者不能够在没有领导者的情况下进行状态变更。因此，当领导者需要将快照发送给跟随者时，这似乎与Raft的强领导者原则相矛盾。

为了解决这个问题，Raft的设计者允许跟随者独立地进行快照，并允许领导者将自己的快照发送给跟随者。跟随者在接收到领导者发送的快照时会检查其自己的日志条目是否已经与领导者的日志条目保持一致，如果不一致，跟随者会将自己的日志条目截断到快照中最后一个包含的日志条目，并重新同步状态。这种方法可以保证所有服务器具有相同的状态，并且不需要违反Raft的强领导者原则。

因此，

1. Raft通过允许跟随者独立进行快照，
2. Raft允许领导者向跟随者发送快照，解决了快照和强领导者原则之间的冲突。



我们考虑过一种基于领导者的替代方法，其中只有领导者创建快照，然后将其发送到每个跟随者。

然而，这种方法有两个缺点。首先，将快照发送到每个跟随者会浪费网络带宽并减缓快照进程。每个跟随者已经拥有生成自己快照所需的信息，而且通常从本地状态生成快照比通过网络发送和接收快照要便宜得多。其次，领导者的实现将会更加复杂。例如，领导者需要在将新的日志条目复制到跟随者的同时并行地向跟随者发送快照，以避免阻塞新的客户请求。

还有两个影响快照性能的问题。首先，服务器必须决定何时进行快照。如果服务器频繁地进行快照，将会浪费磁盘带宽和能源；如果不经常进行快照，则会增加耗尽存储容量的风险，并增加重放日志所需的时间。一种简单的策略是当日志达到固定大小（以字节为单位）时进行快照。如果这个大小被设置为明显大于预期快照大小的值，那么进行快照的磁盘带宽开销将会很小。

第二个性能问题是写入快照可能需要花费大量时间，而我们不希望这会延迟正常操作。解决方案是使用写时复制技术，以便可以接受新的更新而不影响正在编写的快照。例如，使用函数式数据结构构建的状态机自然支持此功能。另外，操作系统的写时复制支持（例如在Linux上的fork）可以用于创建整个状态机的内存快照（我们的实现使用了这种方法）。



## Client interaction

==**Raft的客户端只和领导者交互**==

本节描述了客户端如何与Raft交互，包括客户端如何找到集群领导者以及Raft如何支持线性化语义。这些问题适用于所有基于共识的系统，而Raft的解决方案与其他系统类似。

Raft的客户端将所有请求发送到领导者。

* 当客户端首次启动时，它连接到一个随机选择的服务器。

* 如果客户端的第一个选择不是领导者，则该服务器将拒绝客户端的请求并提供有关它所听到的最新领导者的信息。
* 如果领导者崩溃，客户端请求将超时，然后客户端将使用随机选择的服务器再次尝试。

为了实现线性化语义，客户端为每个命令分配唯一的序列号。状态机跟踪每个客户端处理的最新序列号以及相关响应。如果收到已经执行过的命令，它将立即响应而不重新执行请求。

只读操作可以在不将任何内容写入日志的情况下处理。但是，为了避免返回过时数据，Raft采取了额外的措施。首先，领导者必须拥有关于已提交条目的最新信息。为了找出这些信息，领导者需要在其任期开始时将一个空的no-op条目提交到日志中。其次，领导者在处理只读请求之前必须检查它是否已被废黜。Raft通过使领导者在响应只读请求之前与大多数集群交换心跳消息来处理这一点。或者，领导者可以依靠心跳机制提供租约形式，但这将依赖于时序以确保安全[跳转问题](#hahaha)

总之，Raft通过客户端将所有请求发送给领导者、为每个命令分配唯一序列号、处理只读操作而不写入日志等方式，实现了客户端与Raft的交互，同时支持线性化语义。这些解决方案与其他基于共识的系统类似，有助于实现高效的分布式系统。









## 	gpt

### 什么叫LSM树?

LSM树是一种基于磁盘的数据结构，它将数据存储在内存和磁盘中，旨在提供高效的读取和写入操作。LSM树的名称源自其使用日志结构的方式（Log-Structured Merge Tree）。

LSM树通常由两个部分组成：内存中的数据结构和磁盘中的数据结构。在内存中，LSM树通常使用一种类似于B-tree的数据结构，它允许快速地插入、更新和删除数据。然而，内存是有限的，当内存中的数据达到一定阈值时，LSM树将数据写入到磁盘中的一组有序文件（称为“运行”），并将内存中的数据结构清空。这些运行可以并行地合并成更大的运行，并最终合并成单个运行。合并过程使用归并排序算法，并且可以通过增加并行合并的数量来提高性能。

LSM树被广泛应用于各种系统，如键值存储、数据库和搜索引擎，以提供高效的读取和写入性能。它们的主要优点是它们可以减少磁盘操作次数，从而提高写入性能，并且由于数据存储在磁盘上，它们可以存储非常大的数据集。



### 快照不是状态转移使用的嘛，为什么能用于压缩？

您提出了一个非常好的问题。确实，Raft协议中的快照是用于在不同的服务器之间传输状态而不是压缩的。当快照被应用到服务器时，它们代表了一种状态转移，其中服务器将状态设置为快照中的状态。

然而，快照也可以用于压缩，因为一旦一个服务器应用了一个快照，它就可以删除快照之前的所有日志条目。这是因为快照中包含了服务器状态的完整副本，因此快照之前的日志条目对于重放日志来说已经不再必要。通过删除这些无用的日志条目，Raft可以压缩日志并减少存储空间的使用。

此外，快照中还包含有关最后一个包含的日志条目的元数据，以便在快照应用后恢复正常操作。这些元数据还可以用于支持Raft协议的其他方面，例如一致性检查和集群成员变更。

### 所以这里快照的意思就是讲日志持久化放入磁盘，删除已经持久化的日志，从而压缩日志?

是的，您的理解是正确的。在Raft协议中，快照是将服务器状态写入稳定存储介质（如磁盘）中的过程，并且在这个过程中，所有已经被快照覆盖的日志条目可以被删除。这些日志条目之前包含了被覆盖的服务器状态的历史记录，而现在这些状态已经被包含在了快照中。因此，这些日志条目已经不再需要了，并且可以被删除以压缩日志。

在Raft协议中，快照不是一种压缩算法，而是一种压缩机制。这是因为快照只删除被覆盖的日志条目，而不是对日志中的实际数据进行任何形式的压缩。这种机制可以减少日志的大小，从而降低存储和传输的成本，同时保持日志的完整性和一致性。

### 也就是说快照在持久前也需要不同服务器之间rpc来保证一致?

是的，当领导者需要将快照发送给滞后的跟随者时，它会使用一种名为`InstallSnapshot`的新的RPC来发送快照。在这个RPC的过程中，领导者会将快照中包含的元数据一起发送给跟随者，以便跟随者能够正确地接收和处理快照。在这个过程中，领导者和跟随者之间会进行一些通信协议和数据校验，以确保快照能够正确地被复制和应用。

因此，快照的持久化不仅需要在单个服务器上进行，而且需要跨多个服务器进行同步。Raft通过使用RPC协议和数据校验机制来确保快照在多个服务器之间的正确传输和应用。这可以确保所有服务器都具有相同的状态机和一致的日志条目，从而实现整个集群的状态一致性。

### 另外，操作系统的写时复制支持（例如在Linux上的fork）可以用于创建整个状态机的内存快照（我们的实现使用了这种方法）。这是啥意思？

在Raft中，快照是用来压缩日志的一种方法。当日志变得太大时，Raft会创建一个快照来代替一部分日志。这个快照包含了系统的当前状态，并且会被写入磁盘以供后续恢复使用。

在创建快照时，Raft需要将当前状态机的状态保存下来。如果直接复制整个状态机到磁盘，会产生很大的开销。因此，Raft采用了一种叫做写时复制（Copy-on-Write）的技术，来减少内存和磁盘的使用。

具体地说，Raft在创建快照期间会创建一个只读的状态机副本。这个只读的状态机副本和当前状态机共享大部分数据结构。当需要修改数据时，Raft会使用写时复制技术来创建一个新的副本，而不是修改原始的数据结构。这样可以避免在创建快照期间复制整个状态机的开销，并且可以保证在创建快照期间不会影响正常操作。

一旦快照创建完成，Raft会将这个只读的状态机副本写入磁盘，以创建一个新的快照。这样可以减少磁盘的使用，并提高系统的性能。

### 我懂了，如果这段时间状态机只修改了几个数据，那么快照也只会复制这几个数据，而不会全盘修改?

是的，您说得很对。写时复制技术可以避免在创建快照时复制整个状态机的开销，只需要复制发生了变化的部分。这样可以节省内存和磁盘的使用，并提高系统的性能。

### 什么叫线性化语义?

线性化语义（Linearizability）是一种分布式系统一致性模型，又称为原子一致性（Atomic Consistency）。在线性化语义模型中，系统中的所有操作必须满足以下条件：

1. 原子性：操作是原子的，即要么完全执行，要么完全不执行。这意味着在执行过程中不能被其他操作中断。
2. 顺序一致性：在整个系统中，所有操作都必须按照某种全局顺序执行。这意味着对于任意两个操作 A 和 B，它们在全局顺序中的相对顺序与它们在每个客户端看到的顺序相同。

线性化语义在分布式系统中提供了一种强一致性保证，使得在并发访问和故障发生的情况下，系统的行为看起来仍然像是一个单一的、原子的系统。换句话说，在满足线性化语义的系统中，任何客户端在任何时间点看到的系统状态都是一致的，使得在系统设计和开发过程中更容易推理和处理。

在实现线性化语义的分布式系统中，通常需要使用共识算法来确保全局顺序。例如，Raft、Paxos等共识算法可以帮助分布式系统实现线性化语义。

### 在Raft中处理只读操作时，为了避免返回过时数据，采取了一些额外的措施。以下是详细解释?

1. 领导者需要拥有关于已提交条目的最新信息。为了达到这个目的，领导者在其任期开始时将一个空的no-op（无操作）条目提交到日志中。这样，领导者能够确保它具有关于已提交条目的最新信息，并且在处理只读请求时可以提供准确的数据。

2. 领导者在处理只读请求之前必须检查它是否已被废黜。这是因为一个过时的领导者可能不知道新领导者已经提交了新的数据。为了解决这个问题，Raft要求领导者在响应只读请求之前与集群中的大多数节点交换心跳消息。这样可以确保领导者在处理只读请求时仍处于领导地位，并且其数据是最新的。

   另一种方法是领导者依靠心跳机制提供租约（Lease）形式。在这种情况下，领导者通过与其他节点的心跳交流来维护一个租约。这个租约在一段时间内有效，只有在租约有效期内，领导者才能响应只读请求。这种方法依赖于时序以确保安全，因为如果领导者不能及时更新租约，它将无法响应只读请求。

通过采用这些措施，Raft确保在处理只读操作时提供准确且最新的数据，从而满足分布式系统一致性的需求。这有助于提高系统的可靠性和可用性。

### 为什么只读操作要提供额外措施？

在分布式系统中，只读操作需要额外措施以确保数据的一致性和正确性。原因如下：

1. 数据一致性：在分布式系统中，数据可能分布在多个节点上，这些节点之间的数据可能存在不一致。如果不采取额外措施，只读操作可能从一个过时的节点获取数据，导致返回的数据不一致。因此，需要确保在处理只读请求时，提供准确且最新的数据。
2. 领导者切换：在Raft等共识算法中，领导者负责处理客户端的读写请求。但是，领导者可能因为故障或其他原因而被替换。这种情况下，一个已经被废黜的领导者可能不知道新领导者已经提交了新的数据。为了防止过时的领导者处理只读请求，需要在处理只读操作前检查其有效性。
3. 保证线性化语义：在分布式系统中，线性化语义要求所有操作看起来像是在一个单一的、原子的系统中按照全局顺序执行。为了满足这一要求，只读操作需要确保在处理请求时获取到的数据是最新的，并且与系统中的其他操作保持一致。

通过采用额外措施，分布式系统可以在处理只读操作时确保数据的一致性和正确性。这对于提高系统的可靠性、可用性以及满足线性化语义等一致性需求至关重要

### ==问题9 可是领导者不是已经维护了一个commitIndex,为什么需要加一个空的no-op（无操作）条目提交到日志中来确定哪些日志条目已经被提交==？

<span id="hahaha"></span>

您是对的，领导者确实维护了一个commitIndex来跟踪已提交的日志条目。然而，在新领导者刚开始其任期时，可能会出现一个问题：新领导者可能不知道前一个领导者的commitIndex，因此无法立即确定哪些日志条目已经被提交。这种情况下，添加一个空的no-op条目有助于解决这个问题。

当新领导者在其任期开始时提交一个空的no-op条目，它会等待直到这个条目被大多数节点复制并确认。这个过程中，新领导者将与跟随者节点同步，从而获得关于已提交日志条目的信息。一旦no-op条目被提交，新领导者可以确信其已知的commitIndex是最新的，因为根据Raft算法的要求，新领导者一定具有所有已提交的日志条目。

实际上，这个空的no-op条目在同步过程中起到了一个“屏障”的作用。它确保在新领导者开始处理读写请求之前，已提交日志条目的信息得到了更新。这样，新领导者在处理读操作时能够提供一致性和正确性保证。

因此，尽管领导者维护了commitIndex，但提交一个空的no-op条目有助于确保新领导者在其任期开始时获得关于已提交日志条目的最新信息。这对于处理读操作并提供一致性和正确性保证是必要的。





