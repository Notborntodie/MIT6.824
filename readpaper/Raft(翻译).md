# Raft

[TOC]

## 概要

Raft是一种用于管理复制日志的共识算法。它产生的结果与Paxos一样，而且与Paxos一样有效，但其结构不同于Paxos，这使得Raft比Paxos更容易理解，并且为构建实际系统提供了更好的基础。为了增强可理解性，Raft将共识的关键要素分开

1. 领导者选举
2. 日志复制
3. 安全性

并强制执行**更强的一致性程度**，以减少必须考虑的状态数量。用户研究结果表明，Raft比Paxos更易于学习。Raft还包括一种用于更改集群成员资格的新机制，它使用重叠多数来保证安全性。

## 引言

共识算法允许一组机器作为一个协同的团队工作，可以在其成员的故障情况下继续工作。因此，它们在构建可靠的大型软件系统方面发挥着关键作用。Paxos [15, 16]在过去的十年中主导了共识算法的讨论：大多数共识实现都是基于Paxos或受其影响，并且Paxos已成为教授共识的主要方法。 

不幸的是，尽管有许多试图使其更易于理解的尝试，Paxos仍然很难理解。此外，其架构需要复杂的更改才能支持实际系统。因此，系统构建者和学生都在与Paxos进行斗争。 在我们自己与Paxos进行斗争之后，我们着手寻找一种新的共识算法，该算法可以为系统构建和教育提供更好的基础。我们的方法是不同寻常的，因为我们的主要目标是可理解性：我们能否定义一个适用于实际系统的共识算法，并以比Paxos容易学习得多的方式描述它？此外，我们希望该算法有助于发展对于系统构建者至关重要的直觉。重要的不仅仅是算法的工作，而且很明显为什么它能工作。

这项工作的结果是一种共识算法，称为Raft。在设计Raft时，我们采用了特定的技术来提高可理解性，包括

1. 分解（Raft将领导者选举、日志复制和安全性分开）

2. 状态空间缩减（相对于Paxos，Raft减少了非确定性和服务器之间不一致的方式）

   

   在两所大学的43名学生中进行的用户研究表明，Raft比Paxos容易理解得多：在学习两种算法后，这33名学生能够更好地回答关于Raft的问题而不是关于Paxos的问题。

Raft在许多方面类似于现有的共识算法（尤其是Oki和Liskov的Viewstamped Replication [29，22]），但它具有几个新颖的特点

* **强领导者**：Raft使用比其他共识算法更强的领导方式。例如，日志条目仅从领导者流向其他服务器。这简化了复制日志的管理，并使Raft更易于理解。 
* **领导者选举**：Raft使用**随机定时器**选举领导者。这仅对任何共识算法已经要求的**心跳机制**增加了一小部分机制，同时简单而快速地解决了冲突。
* **成员更改**：Raft用于更改群集中服务器集合的机制使用新的联合共识方法，==在过渡期间两个不同配置的多数重叠。这允许群集在配置更改期间继续正常运行==。

本文的其余部分介绍了复制状态机问题（第2节），讨论了Paxos算法的优点和缺点（第3节），描述了我们对易理解性的一般方法（第4节），介绍了Raft一致性算法（第5-8节），评估了Raft算法（第9节），并讨论了相关工作（第10节）。



##  复制状态机 

共识算法通常出现在复制状态机的背景下[37]。在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使其中一些服务器关闭，它们也可以继续运行。复制状态机用于解决分布式系统中的各种容错问题。例如，具有**单个集群领导者**的大规模系统（例如GFS [8]、HDFS [38]和RAMCloud [33]），通常使用==单独的复制状态机==来管理领导者选举并存储必须在领导者崩溃后仍然存在的配置信息。复制状态机的例子包括Chubby [2]和ZooKeeper [11]。

<img src="http://cdn.zhengyanchen.cn/img202303201507347.png" alt="截屏2023-03-20 15.07.20" style="zoom:40%;" />

*图1：复制状态机架构。共识算法管理一个包含来自客户端的状态机命令的复制日志。状态机从日志中处理相同的命令序列，因此它们产生相同的输出。*

复制状态机通常使用**复制日志**实现，如图1所示。每个服务器都存储包含一系列命令的日志，其状态机按顺序执行。每个日志以相同的命令相同的顺序包含相同的命令，因此每个状态机都处理相同的命令序列。由于状态机是确定性的，因此每个状态机计算相同的状态和相同的输出序列。

保持复制日志一致是共识算法的工作。服务器上的共识模块从客户端接收命令并将其添加到其日志中。**它与其他服务器上的共识模块通信，以确保每个日志最终以相同的顺序包含相同的请求**，即使某些服务器失败。一旦命令被正确复制，每个服务器的状态机按照日志顺序处理它们，并将输出返回给客户端。因此，服务器似乎形成了一个单一的高度可靠的状态机。

实际系统中的共识算法通常具有以下特性： 

* 在所有非拜占庭条件下（包括网络延迟、分区、数据包丢失、重复和乱序等情况），确保**安全性**（不会返回错误结果）。 
* 只要大多数服务器可用且能够彼此通信和与客户端通信，它们就是**available**的。因此，一个典型的五台服务器的集群可以容忍任意两台服务器的故障。服务器的故障被认为是停止的，它们可能稍后从稳定存储中恢复状态并重新加入集群。 
* 它们不依赖于定时机制来确保日志的一致性：即使时钟出现故障和极端消息延迟，最多只会导致可用性问题。
* 在普通情况下，只要集群中的大多数服务器在单个远程过程调用回复的一轮中响应，命令就可以立即完成；少数缓慢的服务器不会影响整个系统的性能。



## 设计可理解性

在设计 Raft 时，我们有几个目标：它必须为系统构建提供完整和实用的基础，以显著减少开发人员所需的设计工作；它必须在所有条件下都是安全的，在典型操作条件下可用；并且它必须对常见操作而言是高效的。但我们最重要的目标，也是最困难的挑战，是可理解性。必须有一个广泛的受众能够轻松理解算法。此外，必须能够对算法形成直觉，以便系统构建者可以进行不可避免的实现扩展。

在设计 Raft 时，我们在许多情况下必须在多种替代方案之间进行选择。在这些情况下，我们根据可理解性评估了替代方案：每个替代方案的解释难度有多大（例如，它的状态空间有多复杂，是否有微妙的影响？），读者完全理解该方法及其含义的难度有多大？

我们认识到在这种分析中存在高度主观性；尽管如此，我们使用了两种通常适用的技术。

* 第一种技术是众所周知的问题分解方法：在可能的情况下，我们将问题分解成可相对独立地解决、解释和理解的单独部分。例如，在 Raft 中，我们将领导者选举、日志复制、安全性和成员更改分开。

* 我们的第二个方法是通过减少要考虑的状态数量来简化状态空间，使系统更加连贯，并尽可能消除不确定性。具体来说，日志不允许有漏洞，并且 Raft 限制了日志彼此不一致的方式。虽然在大多数情况下，我们试图消除不确定性，但有些情况下，不确定性实际上可以提高可理解性。特别地，随机化方法引入了不确定性，但它们倾向于通过以类似的方式处理所有可能的选择（“随便选；没关系”）来减少状态空间。我们使用随机化来简化 Raft 领导者选举算法。

## 5 Raft共识算法



* 什么叫提交？

在分布式系统中，**提交（commit）通常指的是将日志条目应用到状态机的过程，以达到一致的状态。**在Raft协议中，只有被大多数节点（包括领导者自己）复制的日志条目才能被提交，保证了所有节点的状态是一致的。一旦被提交，该条目对应的命令或操作就会被状态机执行，从而改变系统状态。提交是Raft协议保证一致性的关键步骤之一。

Raft是一种管理所描述的复制日志的算法（详见第2节）。

* 图2总结了算法的压缩形式以供参考
* 图3列出了算法的关键属性(==所谓的关键属性就是Raft最终做到的属性==)



<img src="http://cdn.zhengyanchen.cn/img202303231245682.png" alt="截屏2023-03-23 12.45.00" style="zoom:67%;" />



*图 2*



<img src="http://cdn.zhengyanchen.cn/img202303201836354.png" alt="截屏2023-03-20 18.36.16" style="zoom:67%;" />

*图3*

*选举安全性（Election Safety）：在特定的term中最多只能选举出一个leader。 §5.2*

*Leader只追加Leader Append-Only）：leader永远不会覆盖或删除其日志中的条目，只会追加新条目。 §5.3*

*日志匹配（Log Matching）：如果两个日志包含具有相同索引和term的条目，则这些日志在给定索引上的所有条目都相同。 §5.3*

*Leader完整性（Leader Completeness）：如果在给定term中提交了一个日志条目，则该条目将出现在所有高编号term的leader的日志中。 §5.4*

*状态机安全性（State Machine Safety）：如果服务器已将给定索引的日志条目应用于其状态机，则任何其他服务器将不会为相同索引应用不同的日志条目。 §5.4.3*

这些图的要素将在本节其余部分逐个讨论。

Raft通过首先选举一个显著的leader，然后将完全管理复制日志的责任赋予该leader来实现一致性。leader从客户端接受日志条目，将其复制到其他服务器，并告诉服务器何时可以安全地将日志条目应用于其状态机。拥有leader**简化了复制日志**的管理。

例如，leader可以决定将新条目放置在日志中的位置而不需要与其他服务器协商，并且数据从leader流向其他服务器的方式也很简单。leader可能会失败或与其他服务器断开连接，在这种情况下将**选举新的leader**。

考虑到leader的方法，Raft将一致性问题分解为三个相对独立的子问题，将在随后的子段中进行讨论： 

* **Leader election领导选举**：现有的leader失败时必须选择新的leader（第5.2节）。
* **Log replication日志复制**：leader必须从客户端接受日志条目并将其复制到整个集群，强制其他日志与其本身保持一致（第5.3节）。 
* **Safety安全**：Raft的关键安全属性是图3中的State Machine Safety Property：如果任何服务器将特定的日志条目应用于其状态机，那么其他机器也必须要在这里保持一致。第5.4节描述了Raft如何确保此属性；解决方案涉及对第5.2节中描述的选举机制的附加限制。

在介绍共识算法后，本节将讨论可用性问题以及时间在系统中的作用。

### Raft basics

一个Raft集群包含多个服务器；五个是一个典型的数字，可以让系统容忍两个故障。在任何给定时间，每个服务器都处于三种状态之一：

*  **leader**,在正常操作中，有且只有一个leader，所有其他服务器都是followers
* **follower**,followers是被动的：它们不主动发出请求，只是响应leader和candidate的请求。Leader处理所有客户端请求（如果客户端联系follower，则follower将其重定向到leader）。
* **candidate**,第三种状态，candidate，用于选举新的leader，如第5.2节所述。图4显示了这些状态及其转换；下面将讨论这些转换。

<img src="http://cdn.zhengyanchen.cn/img202303201646674.png" alt="截屏2023-03-20 16.46.26" style="zoom:40%;" />

*图4:==server states==. Followers只会响应其他服务器的请求。如果follower没有收到通信，则会变为candidate并发起选举。获得大多数集群投票的candidate将成为新的leader。Leader通常一直运行直到它们失效。*

==是这样的==

1. 一开始，还没有领导者，都是跟随者，由于没有leader发心跳，跟随者会

Raft将时间分成任意长度的**term**，如图5所示。Term使用**连续整数**进行编号。每个term都以一次**选举**开始，其中一个或多个候选者试图成为leader，如第5.2节所述。如果一个candidate赢得选举，那么它将在余下的term中担任leader。

在某些情况下，选举将导致**分裂投票**。在这种情况下，term将以没有leader的状态结束；一个新的term（带有新的选举）很快就会开始。Raft确保在给定的term中最多只有一个leader。

<img src="http://cdn.zhengyanchen.cn/img202303201818482.png" alt="截屏2023-03-20 18.18.17" style="zoom:75%;" />

不同的服务器可能在不同的时间观察term之间的转换，在某些情况下，服务器可能无法观察选举甚至整个term。**Term在Raft中充当逻辑时钟**[14]，它们允许服务器检测过时的信息，例如过时的leader。==每个服务器存储一个当前的term编号，它随着时间单调递增==。

当前term在服务器之间通信时交换

1. 如果一个服务器的当前term比另一个服务器的小，则它将其当前term更新为较大的值。
2. 如果candidate或leader发现其term已过期，则立即返回follower状态
3. 如果服务器接收到带有过时term编号的请求，则拒绝该请求。

Raft服务器使用远程过程调用（RPC）进行通信，基本一致性算法仅需要两种类型的RPC。

* RequestVote RPC由候选者在选举期间（第5.2节）发起，

* Append-Entries RPC由leader发起以复制日志条目并提供一种心跳形式（第5.3节）

* 第7节添加了第三种RPC，用于在服务器之间传输快照

  如果服务器没有及时收到响应，则服务器会重试RPC，并并行发出RPC以获得最佳性能。

### Leader election

Raft使用**心跳机制**来触发领导人选举。当服务器启动时，它们开始作为followers。只要它从leader或candidate接收到有效的RPC，服务器就会保持follower状态。leader定期向所有followers发送心跳（AppendEntries RPC，不携带日志条目）以维护其领导权。如果follower在一段时间内没有收到任何通信，这段时间称为**选举超时**，那么它会假定没有可行的领导人并开始选举新领导人。 

<img src="http://cdn.zhengyanchen.cn/img202303201646674.png" alt="截屏2023-03-20 16.46.26" style="zoom:40%;" />

为了开始选举，follower增加当前term并转换为candidate状态。它然后为自己投票并向集群中的每个其他服务器**并行**发出RequestVote RPC。候选人将在此状态下继续，直到发生以下三种情况之一：

* (a)它赢得了选举

* (b) 另一个服务器建立了自己作为领导者

* (c)一段时间过去了，没有获胜者

  这些结果在下面的段落中分别讨论。 候选人赢得选举的条件是在同一届期内从全集群中获得大多数服务器的选票。**每个服务器在一个特定term内最多为一个候选人投票**，基于先到先服务的原则（请注意：第5.4节增加了对选票的额外限制）。多数规则确保最多只有一个候选人可以赢得特定term的选举（图3中的选举安全属性）。

  <img src="http://cdn.zhengyanchen.cn/img202303201836354.png" alt="截屏2023-03-20 18.36.16" style="zoom:67%;" />

  1. 一旦候选人赢得选举，它就成为领导者。然后，它向所有其他服务器发送心跳消息以建立其领导权并防止新选举。
  2.  在等待选票时，候选人可能会收到来自另一个声称自己是领导者的服务器的AppendEntries RPC。如果leader的term（包含在其RPC中）至少与候选人的当前term一样大，则候选人将认可该leader是合法的，并返回follower状态。如果RPC中的term小于候选人的当前term，则候选人拒绝该RPC并继续保持candidate状态。
  3. 第三种可能的结果是，候选者既没有赢得选举，也没有失败：如果许多跟随者同时成为候选者，则投票可能会分裂，以至于没有候选者获得多数选票。当发生这种情况时，每个候选者将超时并通过增加其术语并启动另一轮Request-Vote RPCs来开始新的选举。但是，如果没有额外的措施，分裂的选票可能会无限重复。

Raft使用**随机选举超时**来确保分裂的选票很少并且可以快速解决。为了在第一次投票时防止分裂的选票，选举超时是从固定间隔（例如150-300ms）中随机选择的。

（**在Raft中，每个服务器都有一个随机化的选举超时计时器。该计时器在服务器启动时随机设置，并且会在每次收到来自领导者的有效RPC时重置。当计时器超时时，服务器会认为当前的领导者失效，然后开始一轮新的选举。选举超时的时间间隔通常是在固定时间范围内随机选择的，例如150毫秒至300毫秒。这样做是为了防止所有服务器在同一时间发起选举，并且可以防止分裂投票的情况发生。由于选举超时是随机选择的，因此不同服务器的超时时间通常是不同的**）

1. 这样就可以将服务器分散开来，以便在大多数情况下，只有一个服务器会超时；它赢得选举并在其他任何服务器超时之前发送心跳。
2. 同样的机制也用于处理分裂的选票。每个候选人在选举开始时重新启动其随机选举超时，并在等待该超时时间到期之前开始下一次选举；这降低了在新选举中再次发生分裂选票的可能性。第9.3节表明，这种方法可以快速选举领导者。

选举是我们在设计替代方案之间选择时如何考虑可理解性的例子。最初，我们计划使用一个排名系统：为每个候选者分配一个唯一的排名，用于在竞争的候选者之间进行选择。如果一个候选者发现另一个排名更高的候选者，它将返回到跟随者状态，以便更容易地赢得下一次选举的更高排名的候选者。我们发现这种方法会在可用性方面产生微妙的问题（如果低排名的服务器需要超时并再次成为候选人，而高排名的服务器失败，但如果它太快地这样做，就会重置向选举领导者的进展）。我们多次对算法进行了调整，但每次调整后都会出现新的边角案例。最终，我们得出结论，随机重试方法更加明显和易于理解

### Log replication

当一个leader被选出后，它开始处理客户端请求。每个客户端请求都包含一个要由复制状态机执行的命令。leader将该命令作为一个新条目附加到它的日志中，然后并行向每个其他服务器发出AppendEntries RPC来复制该条目。当该条目被**安全复制**（如下所述）后，leader将该条目应用于其状态机，并将该执行的结果返回给客户端。如果follower崩溃或运行缓慢，或者网络数据包丢失，leader将无限期地重试AppendEntries RPC（即使它已响应客户端），直到所有follower最终存储所有日志条目为止.(==只要保证大多服务器日志同步即可==)

* 什么叫**安全复制**？

* AppendEntries RPC会包含哪些内容？

  

日志如图6所示组织。每个日志条目存储状态机命令以及该条目当leader接收的term号。日志条目中的term号用于检测日志之间的不一致性，并确保图3中的某些属性。每个日志条目还具有一个整数索引，用于标识其在日志中的位置。

* 日志条目的信息：
  1. 日志索引 log index
  2. 日志条目的term
  3. 日志的操作内容

<img src="http://cdn.zhengyanchen.cn/img202303210951949.png" alt="截屏2023-03-21 09.51.36" style="zoom:50%;" />

*图6:由序号递增的条目组成。每个条目包含其创建的任期（每个方框中的数字）和状态机的命令。如果一个条目可以被应用于状态机，则该条目被视为已提交。*

* AppendEntries RPC（追加日志条目RPC）会包含什么内容
  1. `term`: 领导者的当前任期号。
  2. `leaderId`: 领导者的 ID，以便于跟随者能够重定向请求。
  3. `prevLogIndex`: 发送方的日志中紧随新日志条目之前的那个日志条目的索引值。即，如果发送方的日志中包含了将要发送的日志条目，那么 `prevLogIndex` 就是该日志条目的索引值减一。
  4. `prevLogTerm`: 发送方在 `prevLogIndex` 处的日志条目的任期号。
  5. `entries[]`: 要追加到日志中的条目。也就是要复制到跟随者节点的日志中的新日志条目。
  6. `leaderCommit`: 领导者的已知提交的最高的日志条目的索引值。

* **prelogIndex**是可以知道要添加日志的位置在哪里
* **leaderCommit**让跟随者知道领导者已经commit了哪些日志

leader决定何时**安全**将日志条目应用于状态机，这样的条目称为**已提交**(**committed**)。Raft保证已提交的条目是持久的，并最终将由所有可用状态机执行。一旦创建该日志条目的leader在大多数服务器上复制了该条目（例如，图6中的条目7），该日志条目就**已提交**。这也提交了leader日志中的所有前面的条目，包括由以前的leader创建的条目。第5.4节讨论了在leader更改后应用此规则时的一些微妙之处，并且还表明这个提交的定义是**安全**的。

leader跟踪它知道**已提交**的最高索引，并将该索引包括在未来的AppendEntries RPC中（包括心跳），以便其他服务器最终找出。一旦follower了解到日志条目已提交，它就按日志顺序将该条目应用于其本地状态机。

我们设计了Raft日志机制来维护不同服务器上日志之间的高一致性水平。这不仅简化了系统的行为并使其更加可预测，而且是确保安全性的重要组成部分。Raft维护以下属性，

这些属性共同构成图3中的==日志匹配属性==

* 如果不同日志中的两个条目具有相同的索引和任期，则它们存储相同的命令。
* 如果不同日志中的两个条目具有相同的索引和任期，则在所有先前的条目中，这些日志都是相同的。 

==如何做到的？==

1.  **leader append-only**

第一个属性源于领导者在给定任期和给定日志索引中最多创建一个条目，并且日志条目永远不会改变其在日志中的位置。（**leader append-only**）

2. **log match property**

(**在raft中强制让跟随者一致**)

第二个属性由**AppendEntries**执行的简单一致性检查保证。在发送AppendEntries RPC时，领导者在其日志中包括在新条目之前的**最后一个条目**的索引和任期。如果跟随者在其日志中找不到和最后一个条目具有相同索引和任期的条目，则拒绝新条目。

一致性检查作为归纳步骤：

1. 日志的**初始空状态**满足日志匹配属性，
2. 一致性检查在**扩展日志**时保持日志匹配属性。
3. 因此，每当AppendEntries成功返回时，领导者都知道跟随者的日志与其自己的日志在新条目上是相同的。 在正常操作期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查永远不会失败。

<img src="http://cdn.zhengyanchen.cn/img202303211032800.png" alt="截屏2023-03-21 10.32.14" style="zoom:50%;" />

*图7*

但是，领导者崩溃可能会使日志不一致（旧领导者可能没有完全复制其日志中的所有条目）。这些不一致性可能会随着一系列领导者和跟随者崩溃而不断加重。图7说明了跟随者的日志可能与新领导者的日志不同的方式。跟随者可能缺少领导者上存在的条目，可能具有领导者上不存在的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个任期。

==在Raft中，领导者通过**强制**跟随者的日志复制自己的日志来处理不一致==。这意味着跟随者日志中的冲突条目将被覆盖为来自领导者日志的条目。第5.4节将说明，当与另一个限制条件相结合时，这是安全的。

为了使跟随者的日志与自己的日志保持一致，领导者必须找到两个日志最后一次一致的日志条目，并删除该点之后跟随者日志中的任何条目，然后将该点之后领导者的所有日志条目都发送给跟随者。所有这些操作都是响应于由**AppendEntries RPC**执行的一致性检查。

领导者为每个跟随者维护一个**nextIndex**，它是领导者将发送到该跟随者的下一个日志条目的索引。当领导者第一次上台时，它将所有nextIndex值初始化为其日志中最后一个日志条目之后的索引（下图中为为11）

<img src="http://cdn.zhengyanchen.cn/img202303211032800.png" alt="截屏2023-03-21 10.32.14" style="zoom:50%;" />

如果跟随者的日志与领导者的日志不一致，则下一个AppendEntries RPC中的一致性检查将失败。在拒绝之后(==之前已经提到每次的AppendEntriesRPC首先会做你一次一致性检查，如果失败来，跟随者就会返回拒绝==)，领导者会递减nextIndex并重试AppendEntries RPC。最终，nextIndex将达到领导者和跟随者日志匹配的点。当这种情况发生时，AppendEntries将成功，这将删除跟随者日志中的任何冲突条目并追加来自领导者日志的条目（如果有的话）。一旦AppendEntries成功，跟随者日志就与领导者的日志保持一致，并将在该术语的其余时间内保持一致。

如果需要，协议可以进行优化以减少拒绝的AppendEntries RPC数量。例如，当拒绝AppendEntries请求时，跟随者可以返回冲突条目的任期和它存储该任期的第一个索引。有了这些信息，领导者可以递减nextIndex以跳过该术语中的所有冲突条目。每个带有冲突条目的术语只需要一个AppendEntries RPC，而不是每个条目都需要一个RPC。实际上，我们怀疑这种优化是不必要的，因为失败很少发生，并且不太可能存在许多不一致的条目。

使用这种机制，当领导者上台时，不需要采取任何特殊的措施来恢复日志一致性。它只需开始正常运行，日志就会自动在AppendEntries一致性检查失败时收敛。领导者永远不会覆盖或删除其自己日志中的条目（图3中的Leader Append-Only属性）。

这种日志复制机制展示了第2节中描述的理想的一致性特性：只要大多数服务器正常运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，新条目可以通过一轮RPCs被复制到大多数群集中；而单个缓慢的跟随者不会影响性能。

## ChatGPT



### 所以需要加上选举限制?

是的，这个限制条件就是所谓的“选举限制”，它可以防止在选举期间出现日志不一致的情况。具体来说，当一个候选者发起选举时，它会包含一个“最后日志条目的索引”和“最后日志条目的任期号”两个信息，用于描述自己的日志状态。如果一个跟随者的日志在这两个信息描述的范围内，那么它就会投票给这个候选者。否则，如果它的日志比候选者的日志更新，那么它就会拒绝投票。

这个限制条件的作用是确保只有在候选者的日志比大多数跟随者的日志都要新时，候选者才会被选为领导者。这样就可以保证领导者的日志能够正确地覆盖跟随者的日志，从而保证日志一致性。



### 所以RequestVote RPC包含？

RequestVote RPC包含了候选者的term、候选者的id、候选者的最后一个日志条目的term和index等信息。具体来说：

1. term：候选者的当前任期号，用于让被请求者进行判断是否更新自己的任期号。
2. candidateId：请求选票的候选者的 ID。
3. lastLogIndex：候选者的最后一个日志条目的索引值。
4. lastLogTerm：候选者最后一个日志条目的任期号。

这些信息将被发送到集群中的其他节点，以请求它们的投票。收到RequestVote RPC的节点将会对请求进行一系列的判断，比如当前节点的任期号是否比候选者的任期号大、候选者的日志是否比当前节点更新等，然后再决定是否将票投给该候选者。



